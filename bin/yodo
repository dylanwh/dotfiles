#!/usr/bin/env perl
use strict;
use warnings;
use YAML 'LoadFile', 'DumpFile';
use Term::ANSIColor;
use Getopt::Long;
use List::Util 'max';
use Term::ReadLine;

Getopt::Long::Configure('gnu_getopt');

my $file = ".yodo";
my %option = (
    color => 'auto',
    remove => 0,
    done => 0,
    purge => 0,
);

my %color = (
    veryhigh => 'bold red',
    high     => 'bold yellow',
    medium   => 'white',
    low      => 'cyan',
    verylow  => 'bold blue',
    title    => 'green',
    category => 'bold black',
);

my @priority = qw( veryhigh high medium low verylow );
my %priority = ( veryhigh => 1, high => 2, medium => 3, low => 4, verylow => 5 );

GetOptions(\%option,
    'color=s',
    'category|cat|c=s',
    'remove|r',
    'done|d',
    'purge|P',
    'edit|e',
    'add|a',
    'priority|p=s',
);
my @todo        = sort { priocmp($a->{priority}, $b->{priority}) } read_todo($file);
my $action      = find_action(\%option);

if ($action eq 'add') {
    my $rl = new Term::ReadLine('yodo');
    backup($file, \@todo);
    my $cat = $option{category} || undef,
    my $pri = $option{priority};
    my $text = join(' ', @ARGV);
    until (defined $text and $text =~ /\S/) {
        print colorize('Enter text for the item you are adding.', 'title'), "\n";
        $text = $rl->readline(prompt('text> ', 'reset'));
    }
    if (not $pri) {
        foreach (1 .. 5) {
            my $p = $priority[$_ - 1];
            print colorize("  $_.", 'title'), colorize(" $p", $p);
        }
        print "\n";
        print colorize("Enter a priority from those listed above.", 'title'), "\n";
        $pri = $rl->readline(prompt("priority> ", 'reset'), "medium");
    }

    push @todo, {
        category => $cat,
        priority => priority_name($pri),
        note => $text,
        time => time,
    };
    DumpFile($file, @todo);
} elsif ($action eq 'edit') {
    my $rl = new Term::ReadLine('yodo');
    backup($file, \@todo);
    foreach my $idx (@ARGV) {
        my $i = $idx - 1;
        my $todo = $todo[$i];
        my $text;
        until (defined $text and $text =~ /\S/) {
            print colorize('Modify the text of the item you are editing.', 'title'), "\n";
            $text = $rl->readline(prompt('text> ', 'reset'), $todo->{note});
        }
        foreach (1 .. 5) {
            my $p = $priority[$_ - 1];
            print colorize("  $_.", 'title'), colorize(" $p", $p);
        }
        print "\n";
        print colorize("Enter a priority from those listed above.", 'title'), "\n";
        my $pri = $rl->readline(prompt("priority> ", 'reset'), $todo->{priority});

        $todo->{note} = $text;
        $todo->{priority} = priority_name($pri);
    }
    DumpFile($file, @todo);
} elsif ($action eq 'remove') {
    backup($file, \@todo);
    foreach my $idx (@ARGV) {
        my $todo = delete $todo[ $idx - 1 ];
        print "Deleted $idx: $todo->{note}\n";
    }
    DumpFile($file, grep defined, @todo);
} elsif ($action eq 'done') {
    backup($file, \@todo);
    foreach my $idx (@ARGV) {
        my $i = $idx - 1;
        $todo[$i]{done} = time;
        print "Done: $todo[$i]{note}\n";
    }
    DumpFile($file, grep defined, @todo);
} elsif ($action eq 'purge') {
    backup($file, \@todo);
    my $i = 0;
    foreach my $todo (@todo) {
        if ($todo->{done}) {
            delete $todo[$i];
            print "Purging: $todo->{note}\n";
        }
        $i++;
    }
    DumpFile($file, grep(defined, @todo));
} elsif ($action eq 'list') {
    my $i = 1;
    foreach my $todo (@todo) {
        my $idx = format_idx($i++);
        next if $todo->{done};
        next if $option{category} and ((not $todo->{category}) or $option{category} ne $todo->{category});
        print colorize("  $idx. ", 'title'), colorize(format_note($todo->{note}), $todo->{priority}), " ";

        if (not $option{category}) {
            print $todo->{category} ? "(". colorize($todo->{category}, 'category') .")" : "";
        }
        print "\n";
    }
}

sub priocmp {
    my ($a, $b) = @_;
    $priority{$a} <=> $priority{$b};
}

sub colorize {
    my ($text, $item) = @_;
    if ($option{color} eq 'auto' and -t STDOUT or $option{color} eq 'always') {
        colored($text, $color{$item});
    } else {
        $text;
    }
}

sub format_idx {
    my $size = @todo;
    $size = length "$size";
    sprintf "%${size}d", shift;
}


sub format_note {
    my $size = max (map { length $_->{note} } @todo );
    sprintf "%-${size}s", shift;
}

sub priority_name {
    my $p = shift;

    if ($p =~ /^(very)?(high|low)|medium$/) {
        return $p;
    } elsif ($p =~ /^\d+$/) {
        return $priority[$p - 1] or die "Invalid priority number: $p\n";
    } else {
        die "Invalid priority number: $p\n";
    }
}

sub read_todo {
    my ($file) = @_;
    if (-f $file) {
        LoadFile($file);
    } else {
        return ();
    }
}

sub priority_num {
    my $p = shift;
    if ($p =~ /^\d+$/) {
        return $p;
    } elsif (exists $priority{$p}) {
        return $priority{$p};
    } else {
        die "Invalid priority: $p\n";
    }
}
sub backup {
    my ($file, $todo) = @_;
    DumpFile("$file~", @$todo);
}

sub find_action {
    my ($opt) = @_;
    my $action;
    foreach my $key (qw( add remove purge done edit )) {
        if ($opt->{$key}) {
            die "Cannot specify --$key with --$action!\n" if defined $action;
            $action = $key;
        }
    }
    return $action || 'list';
}

sub prompt {
    my ($t, $c) = @_;
    return chr(1).color($c).chr(2).$t.chr(1).color('reset').chr(2);
}
