#!/usr/bin/env perl
use strict;
use warnings;
use YAML 'LoadFile';
use Palm::Datebook;
use Getopt::Long;
use Time::Piece;
use Time::Seconds;

my @months = qw( 
	Jan Feb Mar 
	Apr May Jun 
	Jul Aug Sep
	Oct Nov Dec
);

my @days = qw( Sun Mon Tue Wed Thu Fri Sat );

Getopt::Long::Configure('gnu_getopt');
my $infile  = "DatebookDB.pdb";
GetOptions('infile|i=s', \$infile);

my $pdb = new Palm::Datebook;
my $meta = LoadFile("$ENV{HOME}/.remind/pda.yml");
$pdb->Load($infile);

my $log = find_log($pdb);
my @log = parse_log($log);
my %ignore = map { ($_->[1], $_[0]) } @log;
my %FSET;

warn "Found ", scalar @log, " log entries.\n";
warn "Scanning datebook...\n";

foreach my $rec (@{ $pdb->{records} }) {
	next if exists $ignore{ $rec->{description} };
	next if $rec->{description} eq 'LOG';
	if ($rec->{note} and $rec->{note} =~ /^##[fc]/s) {
		print "Ignoring floating reminder: $rec->{description}\n";
	}

	if (exists $rec->{repeat} and $rec->{repeat}{type} > 0 ) {
		if ($rec->{repeat}{type} == 1) {
			# daily repeat
			print "REM $months[$rec->{month} - 1] $rec->{day} $rec->{year} *$rec->{repeat}{frequency} ";
		} elsif ($rec->{repeat}{type} == 2) {
			# weekly repeat
			warn "Weekly repeat not supported\n";
			next;
		} elsif ($rec->{repeat}{type} == 3) {
			warn "Monthly by day repeat not supported.\n";
		} elsif ($rec->{repeat}{type} == 4) {
			warn "Monthly by date repeat not supported\n";
		} elsif ($rec->{repeat}{type} == 5) {
			# yearly repeat.
			print "REM $months[$rec->{month} - 1] $rec->{day} ";
		} else {
			die "unknown repeat type: $rec->{repeat}{type}\n";
		}
		if ($rec->{repeat}{end_year}) {
			my ($y, $m, $d) = @{ $rec->{repeat} }{qw( end_year end_month end_day )};
			print "UNTIL $months[$m - 1] $d $y ";
		}
	} else {
		print "REM $months[$rec->{month} - 1] $rec->{day} $rec->{year} ";
	}
	if ($rec->{alarm}) {
		my $unit = $rec->{alarm}{unit};
		my $adv  = $rec->{alarm}{advance};
		my $value;
		my $day = 0;
		if ($unit == 0) {
			$value = $adv;
		} elsif ($unit == 1) {
			$value = ($adv * ONE_HOUR) / ONE_MINUTE;
		} elsif ($unit == 2) {
			$value = $adv;
			$day = 1;
		}

		if ($day) {
			print "WARN _warn$value ";
			$FSET{"_warn$value"}  = "choose(x, $value, 0)";
		} else {
			print "SCHED _alarm$value ";
			$FSET{"_alarm$value"} = "choose(x, $value, 0)";
		}
	}
	if ($rec->{start_hour} != 0xff and $rec->{start_minute} != 0xff) {
		my $dur_hour = $rec->{end_hour} - $rec->{start_hour};
		my $dur_min  = $rec->{end_minute} - $rec->{start_minute};
		print "AT $rec->{start_hour}:$rec->{start_minute} DURATION $dur_hour:$dur_min ";
	}
	print 'TAG @pda ';
	print "MSG $rec->{description}\n";
}

foreach my $f (keys %FSET) {
	print "FSET $f(x) $FSET{$f}\n";
}


sub find_log {
	my $pdb = shift;
	my ($log) = grep { 
		$_->{description} eq 'LOG' and $_->{day} == 1 and $_->{month} == 1 and $_->{year} == 2000;
	} @{ $pdb->{records} };
	die "Cannot find LOG entry.\n" unless $log;
	return $log;
}

sub parse_log {
	my $log = shift;
	map { [split(/ /, $_, 2) ] } split(/\n/, $log->{note});
}
