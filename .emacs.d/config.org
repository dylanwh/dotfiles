#+TITLE: emacs configuration file
#+AUTHOR: Dylan William Hardison
#+EMAIL: dylan@hardison.net
#+OPTIONS: ^:nil

* installation
Copy this file to ~/.emacs.d and add the following to ~/.emacs/init.el:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq package-archives '(("melpa" . "http://melpa.org/packages/")
                           ("org" . "http://orgmode.org/elpa/")
                           ("gnu" .  "http://elpa.gnu.org/packages/"))
        package-enable-at-startup nil)

  (package-initialize)
  (unless (package-installed-p 'use-package)
    (unless (assoc 'use-package package-archive-contents)
      (package-refresh-contents))
    (package-install 'use-package))

  (require 'use-package)
  (use-package org :ensure t)
  (org-babel-load-file "~/.emacs.d/config.org")
#+END_SRC

* environment
** Tweak the gc settings
#+BEGIN_SRC emacs-lisp
  (setq-default gc-cons-threshold 50000000
                gc-cons-percentage 0.5)
#+END_SRC

** add ~/.emacs.d/elisp to load-path

For things that arn't available as an elpa package, add ~/.emacs.d/elisp
to the load-path. This is also where I can put my own utilities functions.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "elisp"))
#+END_SRC

** custom.el
Keep customize settings in its own file (~/.emacs.d/custom.el)
and ... don't bother loading it. customize settings are nice, but they tend to not be very portable
(such as absolute pathnames leaking into some settings).

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load-file custom-file)
#+END_SRC

** bootstrap packages
There are a few packages that need to be loaded before anything else,
because I use them through out this file.
#+BEGIN_SRC emacs-lisp
    (load-library "after")
    (load-library "bind")
    (load-library "my-util")
    (use-package f :ensure t)
    (use-package request :ensure t)
#+END_SRC

** server
I always want an emacs server running.
#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC

** environmental variables
 #+BEGIN_SRC emacs-lisp
   (use-package exec-path-from-shell :ensure t
     :config
     (progn
       (exec-path-from-shell-initialize)
       (exec-path-from-shell-copy-env "TZ")
       (exec-path-from-shell-copy-env "LC_COLLATE")
       (exec-path-from-shell-copy-env "EMAIL")
       (exec-path-from-shell-copy-env "REALNAME")
       (exec-path-from-shell-copy-env "PERL5LIB")
       (exec-path-from-shell-copy-env "PERL_MM_OPT")
       (exec-path-from-shell-copy-env "PERL_MB_OPT")
       (exec-path-from-shell-copy-env "DOCKER_TLS_VERIFY")
       (exec-path-from-shell-copy-env "DOCKER_HOST")
       (exec-path-from-shell-copy-env "DOCKER_CERT_PATH")
       (exec-path-from-shell-copy-env "DOCKER_MACHINE_NAME")
       (exec-path-from-shell-copy-env "GIT_CEILING_DIRECTORIES")))

   (setenv "PAGER" "cat")
   (setenv "GIT_PAGER" "cat")
   (setenv "MANPAGER" "cat")
   (setenv "ANSI_COLORS_DISABLED" "1")
 #+END_SRC
** platform tests
 #+BEGIN_SRC emacs-lisp
   (use-package osx-trash :ensure t
     :if (and (executable-find "trash")
              (eq system-type 'darwin)))
   (use-package reveal-in-osx-finder :ensure t
     :if (eq system-type 'darwin))

   (cl-case system-type
     (darwin (progn
               (setq mac-option-modifier 'meta
                     mac-command-modifier 'super
                     auth-sources '(macos-keychain-internet)))))

   (if (executable-find "gls")
       (setq insert-directory-program "/usr/local/bin/gls"))
 #+END_SRC

* general settings

settings that don't make more sense anywhere else...

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)

  (setq delete-by-moving-to-trash t
        mark-ring-max 64
        global-mark-ring-max 128
        save-interprogram-paste-before-kill t)

  (setq vc-make-backup-files t
        vc-handled-backends '(SVN Git))

  (setq compilation-always-kill t
        compilation-ask-about-save nil

        truncate-partial-width-windows nil

        ;; ediff
        ediff-split-window-function 'split-window-horizontally
        ediff-window-setup-function 'ediff-setup-windows-plain

        ;; better scrolling
        scroll-conservatively 9999
        scroll-preserve-screen-position t)

  (global-auto-revert-mode 1) ;; revert buffers when their files change
  (electric-indent-mode t)    ;; automatic indent
  (transient-mark-mode 1)     ;; lose selection when buffer changes, etc
  (delete-selection-mode 1)   ;; typing replaces selected text.
  (require 'midnight)         ;; clean up old buffers periodically
#+END_SRC
* look and feel
Configure font, theme, and a few other things relating to how
emacs looks.

** fonts
Choose font size based on hostname
#+BEGIN_SRC emacs-lisp
  (let ((system-name-short (car (split-string (system-name) "\\." t))))

    (cl-case (intern system-name-short)
      (thor     (set-frame-font "Fira Mono Medium-10" nil t))
      (mac-thor (set-frame-font "Source Code Pro Light-14" nil t))
      (freya    (set-frame-font "Source Code Pro-9" nil t))))
#+END_SRC

** theme
*** Install zenburn
#+BEGIN_SRC emacs-lisp
  (use-package zenburn-theme :ensure t
    :config
    (progn
      (load-theme 'zenburn t)))
#+END_SRC

*** Install solarized

#+BEGIN_SRC emacs-lisp :tangle no
  (setq solarized-distinct-fringe-background t
        solarized-high-contrast-mode-line nil
        solarized-scale-org-headlines t
        solarized-use-less-bold nil
        solarized-use-more-italic t
        solarized-use-variable-pitch nil)

  (use-package solarized-theme :ensure t
    :config
    (progn
      (load-theme 'solarized-dark t t)
      (load-theme 'solarized-light t t)))

  (defun my-solarized-toggle ()
    (interactive)
    (cond
     ((member 'solarized-dark custom-enabled-themes)
      (set-frame-font "Source Code Pro Light-18" nil t)
      (disable-theme 'solarized-dark)
      (enable-theme 'solarized-light))
     ((member 'solarized-light custom-enabled-themes)
      (set-frame-font "Source Code Pro Light-14" nil t)
      (disable-theme 'solarized-light)
      (enable-theme 'solarized-dark))))
#+END_SRC

*** smart mode line
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line :ensure t
    :init
    (progn
      (setq sml/show-client t
            sml/show-eol t
            sml/mode-width 'right
            sml/show-frame-identification t
            sml/shorten-modes t
            sml/no-confirm-load-theme t
            sml/theme 'dark)
      (sml/setup)))
#+END_SRC

*** Hide minor modes
#+BEGIN_SRC emacs-lisp
  (use-package rich-minority
    :ensure t
    :config
    (setq rm-blacklist
          '(" EvilOrg"
            " ew:mnlt"
            " Helm"
            " MRev"
            " ARev"
            " Guide"
            " Undo-Tree"
            " GitGutter"
            " s-/"
            " Server")))
#+END_SRC

Turn off most of the GUI features. they're wastes of space.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (display-graphic-p) (fringe-mode 16))
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

*** alect-themes
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package alect-themes :ensure t
    :config
    (progn
      (setq alect-display-class '((class color) (min-colors 256)))
      (load-theme 'alect-black t)))
#+END_SRC

** initial buffer settings: just eshell.
I don't want emacs to show anything but an eshell at start-up.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t
        inhibit-startup-echo-area-message t
        inhibit-startup-message t
        initial-buffer-choice #'eshell
        initial-scratch-message "")
#+END_SRC

** annoyances fixed
No ringing bells, no blinking cursor. show current function
and allow 256 xterm colors.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function (lambda () ()))
  (which-function-mode t)     ;; display current function
  (blink-cursor-mode -1)      ;; disable blinking cursor

#+END_SRC

** better buffer names for duplicates
#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :init (setq uniquify-buffer-name-style 'post-forward-angle-brackets  
            uniquify-separator "/"
            uniquify-ignore-buffers-re "^\\*" ; leave special buffers alone
            uniquify-after-kill-buffer-p t))

  (add-hook 'compilation-filter-hook
            (lambda ()
              (when (eq major-mode 'compilation-mode)
                (require 'ansi-color)
                (let ((inhibit-read-only t))
                  (ansi-color-apply-on-region (point-min) (point-max))))))

  (use-package git-gutter-fringe+ :ensure t
    :if (display-graphic-p))

  (use-package git-gutter+
    :ensure t
    :init (global-git-gutter+-mode))
#+END_SRC

** text formatting
Tabs are 4 real spaces, by default we use 80 columns with
a word wrap. Empty lines are indicated in the fringe.
#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
  (setq-default fill-column 80
                default-tab-width 4
                indent-tabs-mode nil
                indicate-empty-lines t
                imenu-auto-rescan t
                word-wrap t)
#+END_SRC

** utf-8
Enable UTF-8 for all the things.
#+BEGIN_SRC emacs-lisp
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

** cleanup whitespace
Use ethan-wspace to handle whitespace issues.
#+BEGIN_SRC emacs-lisp
  (setq mode-require-final-newline nil)

  ;; (use-package ethan-wspace :ensure t)
#+END_SRC
** special face for FIXME/BUG/TODO
#+BEGIN_SRC emacs-lisp
  (use-package fic-mode :ensure t)
#+END_SRC
* save places, history, recent files and backups
** saveplace
#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :init
  (progn
    (setq-default save-place t)))
#+END_SRC

** minibuffer history
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (progn
      (setq savehist-additional-variables '(search ring regexp-search-ring)
            savehist-autosave-interval 60)
      (setq-default history-length 1000)
      (savehist-mode +1)))
#+END_SRC

** recent files
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :ensure t
  :config
  (progn
    (setq recentf-max-saved-items 1000)
    (setq recentf-max-menu-items 500)
    (recentf-mode +1)
    (add-to-list 'recentf-exclude "COMMIT_EDITMSG\\'")
    (run-with-timer 1800 1800 'recentf-save-list)))
#+END_SRC

* file management
** projectile
#+BEGIN_SRC emacs-lisp
  (defun my-project-name (project-root)
    (let ((summary-file (concat project-root "/data/summary")))
      (if (f-exists? summary-file)
          (f-read summary-file)
        (projectile-default-project-name project-root))))

  (use-package projectile :ensure t
    :config
    (progn
      (setq projectile-enable-caching t
            projectile-tags-command "echo /usr/bin/etags.ctags -Re -f \"%s\" %s"))
      ;; (setq projectile-project-name-function #'my-project-name)

      (projectile-global-mode))
#+END_SRC

** dired
#+BEGIN_SRC emacs-lisp
  (use-package dired-x)

  (setq dired-listing-switches "-aBhl  --group-directories-first"
        dired-omit-files "^\\.?#\\|^\\."
        dired-omit-files-p t)
#+END_SRC
** eshell
#+BEGIN_SRC emacs-lisp
  (use-package esh-module
    :init
    (setq eshell-where-to-jump 'end
          eshell-review-quick-commands 'not-even-short-output
          eshell-smart-space-goes-to-end nil

          ;; eshell
          eshell-scroll-to-bottom-on-input 'all

          ;; kill annoying banner
          eshell-banner-message "\n\n"

          ;; em-glob
          eshell-glob-case-insensitive t
          eshell-error-if-no-glob t

          ;; em-hist
          eshell-history-size 4096)
    :config
    (progn
      (load-library "dylan-eshell-commands")
      (load-library "dylan-eshell-prompt")))

  (defun eshell-maybe-bol ()
    (interactive)
    (let ((p (point)))
      (eshell-bol)
      (if (= p (point))
          (beginning-of-line))))

  (defun company-eshell-history (command &optional arg &rest ignored)
    (interactive (list 'interactive))
    (cl-case command
      (interactive (company-begin-backend 'company-eshell-history))
      (prefix (and (eq major-mode 'eshell-mode)
                   (let ((word (company-grab-word)))
                     (save-excursion
                       (eshell-bol)
                       (and (looking-at-p (s-concat word "$")) word)))))
      (candidates (remove-duplicates
                   (->> (ring-elements eshell-history-ring)
                        (remove-if-not (lambda (item) (s-prefix-p arg item)))
                        (mapcar 's-trim))
                   :test 'string=))
      (sorted t)))

  (defun my-eshell-hook ()
    (set (make-local-variable 'company-backends)
         '(company-eshell-history company-files company-dabbrev))
    (define-key eshell-mode-map "\C-a" 'eshell-maybe-bol))

  (add-hook 'eshell-mode-hook #'my-eshell-hook)
#+END_SRC


** git-annex
This just adds a few things to dired mode.

#+BEGIN_SRC emacs-lisp
  (use-package git-annex :ensure t)
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
  (setq magit-last-seen-setup-instructions "1.4.0")
  (use-package magit
    :ensure t
    :config
    (progn
      (setq magit-diff-options '("--histogram"))
      (setq magit-stage-all-confirm nil)

      (defadvice magit-status (around my-magit-fullscreen activate)
        (window-configuration-to-register :magit-fullscreen)
        ad-do-it
        (delete-other-windows))

      (defun my-magit-quit-session ()
        (interactive)
        (kill-buffer)
        (jump-to-register :magit-fullscreen)))

    (after 'evil
      (after 'git-commit-mode
        (add-hook 'git-commit-mode-hook 'evil-emacs-state))

      (after 'magit-blame
        (defadvice magit-blame-file-on (after advice-for-magit-blame-file-on activate)
          (evil-emacs-state))
        (defadvice magit-blame-file-off (after advice-for-magit-blame-file-off activate)
          (evil-exit-emacs-state)))))
#+END_SRC
** tramp
#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (setq tramp-inline-compress-start-size (* 1024 1024)
        tramp-copy-size-limit nil
        tramp-process-connection-type t)
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
  (add-to-list 'tramp-remote-path "/bin")
  (add-to-list 'tramp-remote-path "/usr/bin")
  (add-to-list 'tramp-remote-path "/usr/local/bin")
#+END_SRC

** with-editor
#+BEGIN_SRC emacs-lisp
  (use-package with-editor
    :ensure t
    :config
    (progn
      (add-hook 'shell-mode-hook  'with-editor-export-editor)
      (add-hook 'term-mode-hook   'with-editor-export-editor)
      (add-hook 'eshell-mode-hook 'with-editor-export-editor)

      (define-key (current-global-map)
        [remap async-shell-command] 'with-editor-async-shell-command)
      (define-key (current-global-map)
        [remap shell-command] 'with-editor-shell-command)))

#+END_SRC
* communication
** email

setup msmtp
#+BEGIN_SRC emacs-lisp
  ; use msmtp
  (setq message-send-mail-function 'message-send-mail-with-sendmail)
  (setq sendmail-program "/usr/local/bin/msmtp")
  ; tell msmtp to choose the SMTP server according to the from field in the outgoing email
  (setq message-sendmail-extra-arguments '("--read-envelope-from"))
  (setq message-sendmail-f-is-evil 't)
#+END_SRC

some utilities

#+BEGIN_SRC emacs-lisp
   (defun my-imapfilter ()
     (interactive)
     (let ((default-directory (expand-file-name "~/")))
       (async-shell-command "imapfilter" "*imapfilter*")))
#+END_SRC

*** mu4e
    a very fast local email client.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :commands mu4e
    :if (executable-find "mu")
    :config
    (progn
      (setq mu4e-maildir (expand-file-name "~/mail")
            mu4e-change-filenames-when-moving t
            mu4e-view-show-images t
            mu4e-view-show-addresses t
            mu4e-get-mail-command "mbsync -qa"
            mu4e-my-email-addresses '( dylan@hardison.net
                                       dhardison@cpan.org
                                       dhardison@mozilla.com
                                       dylan@mozilla.com
                                       dylanwh@gmail.com ))

      (when (executable-find "w3m")
        (setq mu4e-html2text-command "w3m -T text/html"))


      (defun my-guess-email-account (msg)
        (let ((maildir (mu4e-message-field msg :maildir)))
          (if (string-match "^/\\(.*?\\)/" maildir)
              (match-string 1 maildir)
            "fastmail")))

      (defun my-guess-trash-folder (msg)
        (concat "/" (my-guess-email-account msg) "/trash"))

      (defun my-guess-sent-folder (msg)
        (concat "/" (my-guess-email-account msg) "/sent"))


      (setq mu4e-sent-folder #'my-guess-sent-folder
            mu4e-drafts-folder "/fastmail/drafts"
            mu4e-trash-folder #'my-guess-trash-folder
            user-mail-address "dylan@hardison.net")
      (use-package mu4e-org)

      (use-package mu4e-maildirs-extension
        :ensure t
        :config (mu4e-maildirs-extension))
      (use-package org-mu4e)))
#+END_SRC
** weechat
   weechat: use irc from inside emacs
*** package
#+BEGIN_SRC emacs-lisp
  (use-package weechat :ensure t
    :defer t
    :commands weechat-connect
    :init
    (progn
      (setq weechat-modules
            '(weechat-sauron weechat-image weechat-button weechat-complete))

      (setq weechat-host-default       "weechat.hardison.net"
            weechat-port-default       19000
            weechat-password-callback  #'my-weechat-password
            weechat-auto-close-buffers t
            weechat-mode-default       'ssl)

      (setq weechat-auto-monitor-buffers '("hardison.#slug"
                                           "hardison.#lobby"
                                           "sine.#lobby"
                                           "mozilla.#bteam"
                                           "mozilla.#bmo"
                                           "mozilla.#bugzilla")))
    :config (use-package weechat-alert :ensure t))
#+END_SRC

*** auth-sources hack
    For osx's keychain, the port number must be a string.

#+BEGIN_SRC emacs-lisp
  (defun my-weechat-password (host port)
    (when (fboundp 'auth-source-search)
      (weechat-message "Using auth-source to retrieve weechat relay password")
      (plist-get
       (car (auth-source-search
             :max 1
             :host host
             :port (number-to-string port)
             :require '(:secret)))
       :secret)))
#+END_SRC

*** my-weechat-start
    Connect to weechat relay without prompting for anything
#+BEGIN_SRC emacs-lisp
  (defun my-weechat-start ()
    (interactive)
    (weechat-connect nil nil))
#+END_SRC

*** functions for dealing with weechat buffers
#+BEGIN_SRC emacs-lisp
  (defun my-weechat-buffers ()
    (--filter (eq 'weechat-mode (buffer-local-value 'major-mode it))
             (buffer-list)))

  (defun my-weechat-kill-buffers ()
    (interactive)
    (--each (my-weechat-buffers)
      (kill-buffer it)))

  (defun my-weechat-switch-buffer ()
    (interactive)
    (let ((helm-source-weechat-list (helm-make-source "Weechat Buffer" 'helm-source-buffers
                                      :candidates (--map (buffer-name it) (my-weechat-buffers)))))
  
      (helm
       :buffer "*helm weechat*"
       :keymap helm-buffer-map
       :truncate-lines helm-buffers-truncate-lines
       :sources '(helm-source-weechat-list ))))
#+END_SRC

** google-translate
   use google translate from any buffer.
#+BEGIN_SRC emacs-lisp
  (use-package google-translate
    :ensure t
    :commands (google-translate-at-point google-translate-smooth-translate)
    :config (require 'google-translate-smooth-ui))
#+END_SRC
* misc utilities
** bmo stuff

   Most of my customizations for working on bugzilla.mozilla.org.
   There's also some stuff for org-mode later in this file

   - [[*bmo links][bmo org-mode links]]
   - [[*bmo eshell stuff][bmo eshell stuff]] 


   #+BEGIN_SRC emacs-lisp
     (defvar bz-url "http://bugzilla.vm/")
     (defvar bz-dir "/scp:bugzilla.vm:/opt/bugzilla")

     (defun bz-browse-site ()
       (interactive)
       (browse-url (concat bz-url (projectile-default-project-name (projectile-project-root)))))

     (defun bz-browse-bug ()
       (interactive)
       (let ((bug-id (projectile-default-project-name (projectile-project-root))))
         (when (string-match "^[0-9]+$" bug-id)
           (browse-url (concat  "https://bugzilla.mozilla.org/show_bug.cgi?id=" bug-id)))))

     (defun bz-new (bug-id)
       "start working on a new bug"
       (interactive "s")
       (let ((default-directory bz-dir))
         (async-shell-command (format "bz new %s" bug-id) (format "*bznew:%s*" bug-id))))

     (defun bz-list ()
       (mapcar #'car
               (remove-if-not (lambda (x) (and (cadr x) (not (or (equal (car x) "..") (equal (car x) ".")))))
                              (directory-files-and-attributes (concat bz-dir "/htdocs")))))

     (defun bz-bug-id-p (bug-id) (not (null (string-match "^[0-9]+$" bug-id))))
     (defun bz-list-bugs () (remove-if-not #'bz-bug-id-p (bz-list)))

     (defun bz-summary ()
       "Show summary for current bug in projectile root"
       (interactive)
       (message (f-read (concat (projectile-project-root) "/data/summary"))))

     (defun bz-checksetup ()
       "Run checksetup.pl in the current project"
       (interactive)
       (projectile-with-default-dir (projectile-project-root)
         (async-shell-command "perl checksetup.pl")))

     (defun bz-goto (bug-dir &optional switches)
       (interactive (let ((default-directory (f-join bz-dir "htdocs/")))
                      (dired-read-dir-and-switches "")))
       (switch-to-buffer (dired-noselect bug-dir switches)))

     (defun bmo-summary (bug-id)
       (let ((bug-dir (f-join bz-dir (format "htdocs/%s" bug-id))))
         (if (f-dir? bug-dir)
             (f-read (f-join bug-dir "data" "summary"))
           (let ((response (request (format "https://bugzilla.mozilla.org/rest/bug/%s" bug-id)
                                    :params '( ("include_fields" . "summary") )
                                    :parser 'json-read
                                    :sync t)))
             (cdr (assq 'summary (aref (cdr (assq 'bugs (request-response-data response))) 0)))))))
   #+END_SRC
** org-mode
#+BEGIN_SRC emacs-lisp
    (require 'org-mouse)
    (require 'org-protocol)
    (require 'org-eshell)
    (require 'org-mobile)
    (require 'ob-js)

    (setq org-agenda-files '("~/org/bugzilla.org"
                             "~/org/bmo.org"
                             "~/org/outreachy.org"
                             "~/.emacs.d/config.org"
                             "~/org/elastic-quick-search.org"
                             "~/org/notes.org"))

    (setq org-babel-load-languages '((emacs-lisp . t)
                                     (perl . t)
                                     (sql . t)
                                     (js . t)))

  (setq org-confirm-babel-evaluate              nil
        org-confirm-elisp-link-function         nil
        org-default-notes-file                  "~/org/notes.org"
        org-enforce-todo-checkbox-dependencies  t
        org-log-done                            'time
        org-log-into-drawer                     t
        org-open-directory-means-index-dot-org  t
        org-refile-allow-creating-parent-nodes  'confirm
        org-refile-use-outline-path             'file
        org-refile-targets '((org-agenda-files :level . 1))
        org-return-follows-link                 t
        org-src-fontify-natively                t
        org-tab-follows-link                    t
        org-tags-column                         0)
#+END_SRC
*** Load epresent, for presentations from org-mode buffers

#+BEGIN_SRC emacs-lisp
  (use-package epresent
    :ensure t
    :config
    (progn
      (setq epresent-src-blocks-visible nil
            epresent-frame-level 2)))
            
#+END_SRC

*** bmo links
This makes it possible to link to bmo bugs using the "bmo:" syntax.

#+BEGIN_SRC emacs-lisp
  (defun my-org-describe-link (link description)
    (cond ((string-match "^bmo:\\([0-9]+\\)" link)
           (let ((bug-id (match-string 1 link)))
             (format "Bug %s - %.75s" bug-id (bmo-summary bug-id))))
          (t (or description link))))


  (defun my-org-open-bmo (bug-id)
    (browse-url (format "https://bugzilla.mozilla.org/show_bug.cgi?id=%s" bug-id)))

  (org-add-link-type "bmo" #'my-org-open-bmo)
  (setq org-make-link-description-function #'my-org-describe-link)
#+END_SRC

*** ox publish
#+BEGIN_SRC emacs-lisp
  (require 'ox-publish)
  (setq org-publish-project-alist
        '(("org-notes"
           :base-directory "~/org/"
           :base-extension "org"
           :publishing-directory "~/pub/org"
           :recursive t
           :publishing-function org-html-publish-to-html
           :headline-levels 4             ; Just the default for this project.
           :auto-preamble t
           )))
#+END_SRC
*** ox-rst
For wrting reports and other documentation.

#+BEGIN_SRC emacs-lisp
  (use-package ox-rst :ensure t)
#+END_SRC
*** cpan links
 Things like [[cpan:Moose]]

 #+BEGIN_SRC emacs-lisp
   (add-to-list 'org-link-abbrev-alist '("cpan" . "https://metacpan.org/pod/%h"))
 #+END_SRC

*** mediawiki
#+BEGIN_SRC emacs-lisp
(use-package ox-mediawiki :ensure t)
#+END_SRC
** ham-mode
   Html As Markdown. Transparently edit an html file using markdown.

   When this mode is activated in an html file, the buffer is
   converted to markdown and you may edit at will, but the file is
   still saved as html behind the scenes. 

   See `ham-mode-markdown-to-html-command' and `ham-mode--save-as-html' on

#+BEGIN_SRC emacs-lisp
  (use-package ham-mode :ensure t
    :if (executable-find "markdown"))
#+END_SRC
** rainbow mode
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode :ensure t)
#+END_SRC
** alerts
#+BEGIN_SRC emacs-lisp
  (use-package alert :ensure t)
#+END_SRC
** sauron
   Configure sauron for notification support

#+BEGIN_SRC emacs-lisp
  (use-package sauron :ensure t
    :config
    (progn
      (add-hook 'sauron-event-added-functions 'sauron-alert-el-adapter)
      (setq sauron-modules '(sauron-org sauron-notifications))
      (setq sauron-max-line-length nil
            sauron-hide-mode-line t
            sauron-min-priority 3
            sauron-watch-patterns '("\\btea\\b"))))
#+END_SRC
** xkcd


#+BEGIN_SRC emacs-lisp
  (use-package xkcd :ensure t :commands xkcd)
#+END_SRC
** url decode region
#+BEGIN_SRC emacs-lisp
  (defun url-decode-region (start end)
    "Replace a region with the same contents, only URL decoded."
    (interactive "r")
    (let ((text (url-unhex-string (buffer-substring start end))))
      (delete-region start end)
      (insert text)))
#+END_SRC
** smart quotes
#+BEGIN_SRC emacs-lisp
  (defun replace-smart-quotes (beg end)
    "Replace 'smart quotes' in buffer or region with ascii quotes."
    (interactive "r")
    (format-replace-strings '(("\x201C" . "\"")
                              ("\x201D" . "\"")
                              ("\x2018" . "'")
                              ("\x2019" . "'"))
                            nil beg end))
#+END_SRC

** startup stuff I like
#+BEGIN_SRC emacs-lisp
  (defun my-services ()
    (sauron-start)
    (my-weechat-start))
#+END_SRC
* typing utilities
** smart move beginning of line
#+BEGIN_SRC emacs-lisp
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'smarter-move-beginning-of-line)

#+END_SRC
** guide-key
   Use guide-key to help figure out what things do.

#+BEGIN_SRC emacs-lisp
  (use-package guide-key
    :ensure t
    :init
    (progn
      (setq guide-key/guide-key-sequence '("C-x" "C-c" "," "C-w" "SPC")
            guide-key/recursive-key-sequence-flag t
            guide-key/popup-window-position 'bottom)
      (guide-key-mode 1)))
#+END_SRC

** more pcomplete
#+BEGIN_SRC emacs-lisp
  (use-package pcomplete-extension :ensure pcomplete-extension)
#+END_SRC
** yassnippets
#+BEGIN_SRC emacs-lisp 
    (use-package yasnippet
      :ensure t
      :config
      (progn
        (let* ((yas-install-dir (car (file-expand-wildcards (concat package-user-dir "/yasnippet-*"))))
               (dir (concat yas-install-dir "/snippets/js-mode")))
          (when (file-exists-p dir)
            (delete-directory dir t)))

        (setq yas-fallback-behavior 'return-nil
              yas-also-auto-indent-first-line t)
        (add-to-list 'yas-snippet-dirs (concat user-emacs-directory "snippets"))

        (add-hook 'after-init-hook
                  '(lambda ()
                     (yas-reload-all)))

        (add-hook 'prog-mode-hook 'yas-minor-mode)
        (add-hook 'html-mode-hook 'yas-minor-mode)))
#+END_SRC
** company-mode

#+BEGIN_SRC emacs-lisp
  (use-package company :ensure t
    :config
    (progn
      (setq company-idle-delay 0.5)
      (setq company-tooltip-limit 10)
      (setq company-minimum-prefix-length 2)
      ;; invert the navigation direction if the the completion popup-isearch-match
      ;; is displayed on top (happens near the bottom of windows)
      (setq company-tooltip-flip-when-above t)
      (add-to-list 'company-backends 'company-yasnippet)

      (add-hook 'after-init-hook 'global-company-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp :ensure t)
#+END_SRC

** smartparens

#+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :ensure t
      :config
      (progn
        (require 'smartparens-config)

        (setq sp-show-pair-delay 0
              sp-show-pair-from-inside t
              sp-autoescape-string-quote nil
              sp-autoinsert-if-followed-by-same 1
              sp-highlight-pair-overlay t)

        (sp-use-smartparens-bindings)
        (show-smartparens-global-mode t)
        (show-paren-mode -1)

        (defun my-open-block-c-mode (id action context)
          (when (eq action 'insert)
            (newline)
            (indent-according-to-mode)
            (forward-line -1)
            (indent-according-to-mode)))

        (sp-pair "{" nil :post-handlers
                 '(:add (my-open-block-c-mode "RET")))
        (sp-pair "[" nil :post-handlers
                 '(:add (my-open-block-c-mode "RET")))

        (with-eval-after-load 'cperl-mode
          (define-key cperl-mode-map "{" nil))

        ;; fix conflict where smartparens clobbers yas' key bindings
        (defadvice yas-expand (before advice-for-yas-expand activate)
          (sp-remove-active-pair-overlay))))
#+END_SRC

** undo-tree
Before loading evil, configure undo-tree.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :init
    (progn
      (setq undo-tree-auto-save-history t
            undo-tree-visualizer-timestamps t
            undo-tree-visualizer-diff t)))
#+END_SRC
** ace-mode
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode :ensure t)
#+END_SRC
* navigation utilities
** ag
#+BEGIN_SRC emacs-lisp
  (use-package ag :ensure t)
#+END_SRC
** bookmarks
   bookmarks in the data dir too.
#+BEGIN_SRC emacs-lisp
  (setq bookmark-save-flag 1 ) ;; save after every change
#+END_SRC
** google-this
#+BEGIN_SRC emacs-lisp
  (use-package google-this :ensure t)
#+END_SRC
** helm
** springboard

For when you need to run a command in a different directory.

#+BEGIN_SRC emacs-lisp
  (use-package springboard :ensure t
    :config
    (progn
      (setq springboard-directories '("~/"))
      )
    :bind (([f2] . springboard)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :init
    (progn
      (require 'helm-config)

      (setq helm-ff-transformer-show-only-basename nil
            helm-command-prefix-key                "C-c h"
            helm-quick-update                      t
            helm-yank-symbol-first                 t
            helm-move-to-line-cycle-in-source      t
            helm-buffers-fuzzy-matching            t
            helm-bookmark-show-location            t
            helm-split-window-in-side-p            t
            helm-ff-file-name-history-use-recentf  t
            helm-ff-auto-update-initial-value      t)

      (helm-mode 1)
      (helm-adaptive-mode 1)
      (helm-autoresize-mode 1)

      (autoload 'helm-descbinds      "helm-descbinds" t)
      (autoload 'helm-eshell-history "helm-eshell"    t)
      (autoload 'helm-esh-pcomplete  "helm-eshell"    t)

      (add-hook 'eshell-mode-hook
                #'(lambda ()
                    ;; (define-key eshell-mode-map
                    ;;   (kbd "<tab>")     #'helm-esh-pcomplete)
                    (define-key eshell-mode-map
                      (kbd "C-c C-l") #'helm-eshell-history)
                    (define-key eshell-mode-map
                      (kbd "C-r") #'helm-eshell-history)))

      (setq helm-google-suggest-use-curl-p (executable-find "curl"))

      ;(use-package helm-company :ensure t)
      (use-package helm-swoop :ensure t)
      (use-package helm-ag :ensure t)
      (use-package helm-projectile
        :ensure t
        :config (helm-projectile-on))
      (use-package helm-descbinds :ensure t)))

  (defun my-projectile-helm-ag ()
    (interactive)
    (projectile-with-default-dir (projectile-project-root)
      (helm-ag)))
#+END_SRC

** registers
#+BEGIN_SRC emacs-lisp
  (set-register ?e '(file . "~/.emacs.d/config.org"))
  (set-register ?m '(file . "~/.mbsyncrc"))
  (set-register ?n '(file . "~/org/notes.org"))
  (set-register ?b '(file . "~/org/bugzilla.org"))
  (set-register ?q '(file . "~/org/elastic-quick-search.org"))
  (set-register ?i '(file . "~/.imapfilter/config.lua"))
#+END_SRC
* programming languages
** Flycheck
#+BEGIN_SRC emacs-lisp

  (defun my-flycheck-perl-working-dir (orig &rest args)
    (if (derived-mode-p 'cperl-mode)
        (projectile-project-root)
      (apply orig args)))

  (use-package flycheck :ensure t
    :config
    (progn
      (advice-add 'flycheck-compute-working-directory :around #'my-flycheck-perl-working-dir)))

  (defun setup-flycheck-perl-project-path ()
    (let ((root (ignore-errors (projectile-project-root)))
          (inc-path (make-variable-buffer-local 'flycheck-perl-include-path)))
      (when root
        (add-to-list inc-path root)
        (add-to-list inc-path (f-join root "local/lib/perl5")))))

  (add-hook 'cperl-mode-hook #'setup-flycheck-perl-project-path)
#+END_SRC
** Perl
*** perltidy
#+BEGIN_SRC emacs-lisp
  (use-package perltidy)
#+END_SRC

*** perldoc
helm perldoc stuff
#+BEGIN_SRC emacs-lisp
  (use-package helm-perldoc
    :ensure t
    :init (progn
            (with-eval-after-load 'cperl-mode
                 (helm-perldoc:setup))

            ;; auto carton setup
            (add-hook 'cperl-mode-hook 'helm-perldoc:carton-setup)))
#+END_SRC

*** cperl-mode
#+BEGIN_SRC emacs-lisp
  (defun my-cperl-mode ()
    (cperl-set-style "BSD")
    (setq cperl-indent-parens-as-block t
          cperl-close-paren-offset -4
          cperl-font-lock t
          cperl-highlight-variables-indiscriminately t
          cperl-electric-lbrace-space nil
          cperl-electric-parens nil
          cperl-electric-linefeed nil
          cperl-electric-keywords nil
          cperl-info-on-command-no-prompt t
          cperl-clobber-lisp-bindings t
          cperl-lazy-help-time 3
          cperl-invalid-face nil)

    (make-face 'cperl-comment-face)
    (set-face-background 'cperl-comment-face nil)
    (set-face-foreground 'cperl-comment-face "pink")
    (set-face-background 'cperl-array-face nil)
    (set-face-background 'cperl-hash-face nil)

    (set (make-local-variable 'font-lock-comment-face) 'cperl-comment-face)  
    (yas-minor-mode 1)
    (smartparens-mode 1))

  (use-package cperl-mode
    :init
    (progn
      (defalias 'perl-mode 'cperl-mode)

      (add-hook 'cperl-mode-hook #'my-cperl-mode)

      (make-face 'cperl-comment-face)
      (set-face-background 'cperl-comment-face nil)
      (set-face-foreground 'cperl-comment-face "pink")))

#+END_SRC

*** bugzilla bits

#+BEGIN_SRC emacs-lisp
  (defun perl-bugilla? (dir)
    (f-exists? (f-join dir "checksetup.pl")))

  (defun perl-bugzilla-extension? (perl-dir file)
    (and (perl-bugzilla? perl-dir)
         (f-ancestor-of? (f-join perl-dir "extensions") file)))

  (defun perl-cpan? (dir)
    (and (f-dir? (f-join dir "lib"))
         (or (f-exists? (f-join dir "META.yml"))
             (f-exists? (f-join dir "Makefile.PL"))
             (f-exists? (f-join dir "META.json")))))

  (defun my-find-perl-dir (path)
    (when (f-exists? path)
      (f--traverse-upwards (or (perl-bugzilla? it)
                               (perl-cpan? it))
                           path)))

  (defun my-perl-module-file (file)
    (let* ((dir (f-dirname file))
           (perl-dir (or (my-find-perl-dir dir) dir)))
      (cond ((perl-bugzilla-extension? perl-dir file)
             (let ((ext-dir (f-dirname (f-relative file (f-join perl-dir "extensions")))))
               (f-join "Bugzilla" "Extension" ext-dir
                       (f-relative file (f-join perl-dir "extensions" ext-dir "lib")))))
            ((perl-bugzilla? perl-dir)
             (f-relative file perl-dir))
            ((perl-cpan? perl-dir)
             (f-relative file (f-join perl-dir "lib")))
            (t (f-relative file default-directory)))))

  (defun my-perl-module-name (file)
    (replace-regexp-in-string "/" "::" (f-no-ext (my-perl-module-file file))))
#+END_SRC

** Javascript
lots of javascript doo-dads

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure js2-mode
    :mode "\\.js"
    :interpreter "node"
    :init
    (setq js2-highlight-level 3
          js2-global-externs '("$" "window" "BUGZILLA" "localStorage" "jQuery")
          js2-basic-offset 4)
    :config
    (progn
      (use-package js2-refactor
        :ensure js2-refactor
        :init (js2r-add-keybindings-with-prefix "C-c C-m"))

      (use-package tern :ensure t
        :if (executable-find "tern")
        :init
        (progn
          (add-hook 'js2-mode-hook
                    '(lambda () (tern-mode t)))
          (eval-after-load 'company-mode
            (use-package company-tern :ensure t))))))
#+END_SRC
** web
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure web-mode
    :mode ( ("\\.html?\\'" . web-mode)
            ("\\.tmpl\\'"  . web-mode)))

  (defun my-web-mode-hook ()
    "Hooks for Web mode."
    (setq web-mode-markup-indent-offset 2
          web-mode-script-padding 2
          web-mode-code-indent-offset 2)
  
    (setf (cdr (assoc "template-toolkit" web-mode-engine-open-delimiter-regexps))
          "\\[%"))

  (add-hook 'web-mode-hook 'my-web-mode-hook)

  (setq web-mode-engines-alist
        '(("php" . "\\.phtml\\'")
          ("template-toolkit" . "\\.tmpl\\'")))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.css\\'" . css-mode))
#+END_SRC
** config files
Syntax highlighting for ssh config, nginx config, vimrc (haha), yaml and lua.

#+BEGIN_SRC emacs-lisp
  (use-package ssh-config-mode
    :ensure t
    :mode ((".ssh/config\\'"       . ssh-config-mode)
           ("sshd?_config\\'"      . ssh-config-mode)
           ("known_hosts\\'"       . ssh-known-hosts-mode)
           ("authorized_keys2?\\'" . ssh-authorized-keys-mode)))

  (use-package nginx-mode
    :ensure t
    :mode "/etc/nginx/.*")

  (use-package vimrc-mode
    :ensure t
    :mode "\.vimrc")

  (use-package  gitignore-mode
    :ensure t
    :mode "\.gitignore")

  (use-package  gitconfig-mode
    :ensure t
    :mode "\.git/?config")

  (use-package dockerfile-mode
    :ensure t
    :mode "Dockerfile")

  (use-package yaml-mode
    :ensure t
    :mode "\\.yml$"
    :init (add-hook 'yaml-mode-hook
                    '(lambda ()
                       (define-key yaml-mode-map "\C-m" 'newline-and-indent))))

  (use-package lua-mode
    :ensure t
    :mode "\\.lua$")


#+END_SRC
** racket
#+BEGIN_SRC emacs-lisp
  (use-package racket-mode :ensure t)
#+END_SRC

** elisp
things to make elisp hacking for more

#+BEGIN_SRC emacs-lisp
  (eval-after-load "dash" '(dash-enable-font-lock))
  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
               (put 'case 'lisp-indent-function 'cond)
               (set (make-local-variable 'company-backends) '(company-elisp))))
#+END_SRC

** elasticsearch
#+BEGIN_SRC emacs-lisp
  (use-package es-mode :ensure t)
#+END_SRC
** bison
#+BEGIN_SRC emacs-lisp
  (use-package bison-mode :ensure t)
#+END_SRC
* global keybindings

#+BEGIN_SRC emacs-lisp
    (use-package shell-switcher
      :ensure t
      :init (setq shell-switcher-mode t))
    (add-hook 'eshell-mode-hook 'shell-switcher-manually-register-shell)
#+END_SRC

a bunch of global key bindings
 
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "C-x C-m") 'helm-M-x)

  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-=") 'er/expand-region)

  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c i") 'my-imapfilter)
  (global-set-key (kbd "C-c b c") 'bz-checksetup)
  (global-set-key (kbd "C-c m")  'mu4e)

  (global-set-key (kbd "C-c s s") 'sauron-start)
  (global-set-key (kbd "C-c s d") 'sauron-stop)
  (global-set-key (kbd "C-c s t") 'sauron-toggle-hide-show)
  (global-set-key (kbd "C-c s c") 'sauron-clear)

  (global-set-key (kbd "C-c w s") 'my-weechat-start)
  (global-set-key (kbd "C-c w d") 'weechat-disconnect)
  (global-set-key (kbd "C-c w K") 'my-weechat-kill-buffers)
  (global-set-key (kbd "C-c w r") 'weechat-reload-buffer)
  (global-set-key (kbd "C-c w m") 'weechat-monitor-buffer)
  (global-set-key (kbd "C-c w b") 'my-weechat-switch-buffer)

  (global-set-key (kbd "C-x b")   #'helm-mini)
  (global-set-key (kbd "C-x C-b") #'helm-buffers-list)
  (global-set-key (kbd "C-x C-f") #'helm-find-files)
  (global-set-key (kbd "C-x C-r") #'helm-recentf)
  (global-set-key (kbd "C-x r l") #'helm-filtered-bookmarks)

  (global-set-key (kbd "C-x k")   'kill-this-buffer)
  (global-set-key (kbd "C-x p")   'proced)
  (global-set-key (kbd "C-s")     'isearch-forward-regexp)
  (global-set-key (kbd "C-M-s")   'isearch-forward)
  (global-set-key (kbd "C-r")     'isearch-backward-regexp)
  (global-set-key (kbd "C-M-r")   'isearch-backward)

  ;; (global-set-key (kbd "C-w") 'evil-window-map)
#+END_SRC
* evil keybindings
Setup evil with some very vim-like defaults.

** goto-last-change (needed for evil)

#+BEGIN_SRC emacs-lisp
  (use-package goto-last-change :ensure t)
#+END_SRC

** turn on evil
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :config
    (progn
      (setq evil-search-module           'evil-search
            evil-symbol-word-search      t
            evil-magic                   'very-magic
            evil-want-C-w-delete         nil
            evil-want-C-w-in-emacs-state t)

      (evil-mode 1)

      (add-to-list 'evil-emacs-state-modes 'sauron-mode)
      (add-to-list 'evil-emacs-state-modes 'epresent-mode)
      (add-to-list 'evil-insert-state-modes 'weechat-mode)
      (add-to-list 'evil-insert-state-modes 'sql-interactive-mode)
      (add-to-list 'evil-insert-state-modes 'racket-repl-mode)

      (unless (display-graphic-p)
        (evil-esc-mode -1))

      (define-key evil-normal-state-map (kbd "SPC o") 'imenu)
      (define-key evil-normal-state-map (kbd "SPC b") 'switch-to-buffer)

      (define-key evil-normal-state-map (kbd "C-b") 'evil-scroll-up)
      (define-key evil-normal-state-map (kbd "C-f") 'evil-scroll-down)

      (define-key evil-normal-state-map (kbd "[ SPC") (bind (evil-insert-newline-above) (forward-line)))
      (define-key evil-normal-state-map (kbd "] SPC") (bind (evil-insert-newline-below) (forward-line -1)))
      (define-key evil-normal-state-map (kbd "[ e") (kbd "ddkP"))
      (define-key evil-normal-state-map (kbd "] e") (kbd "ddp"))
      (define-key evil-normal-state-map (kbd "[ b") 'previous-buffer)
      (define-key evil-normal-state-map (kbd "] b") 'next-buffer)
      (define-key evil-normal-state-map (kbd "[ q") 'previous-error)
      (define-key evil-normal-state-map (kbd "] q") 'next-error)

      (define-key evil-normal-state-map (kbd "g p") (kbd "` [ v ` ]"))

      (define-key evil-motion-state-map "j" 'evil-next-visual-line)
      (define-key evil-motion-state-map "k" 'evil-previous-visual-line)

      (define-key evil-normal-state-map (kbd "Q") 'my-window-killer)
      (define-key evil-normal-state-map (kbd "Y") (kbd "y$"))

      (evil-define-key 'visual emacs-lisp-mode (kbd ", e") 'eval-region)

      ;; emacs lisp
      (evil-define-key 'normal emacs-lisp-mode-map "K" (bind (help-xref-interned (symbol-at-point))))

      (define-key evil-normal-state-map (kbd "[ h") 'git-gutter+-previous-hunk)
      (define-key evil-normal-state-map (kbd "] h") 'git-gutter+-next-hunk)
      (evil-ex-define-cmd "Gw" (bind (git-gutter+-stage-whole-buffer)))
      (define-key evil-visual-state-map (kbd "SPC SPC") 'helm-M-x)
      (define-key evil-normal-state-map (kbd "SPC SPC") 'helm-M-x)
      (define-key evil-normal-state-map (kbd "g b") 'helm-mini)
      (define-key evil-normal-state-map (kbd "SPC f") 'helm-find-files)
      (define-key evil-normal-state-map (kbd "SPC o") 'helm-semantic-or-imenu)
      (define-key evil-normal-state-map (kbd "SPC t") 'helm-etags-select)
      (define-key evil-normal-state-map (kbd "SPC y") 'helm-show-kill-ring)
      (define-key evil-normal-state-map (kbd "SPC m") 'helm-bookmarks)
      (define-key evil-normal-state-map (kbd "SPC r") 'helm-register)
      (define-key evil-normal-state-map (kbd "SPC l") 'helm-swoop)
      (define-key evil-normal-state-map (kbd "SPC L") 'helm-multi-swoop)
      (define-key evil-normal-state-map (kbd "g ]") 'etags-select-find-tag-at-point)
      (evil-define-key 'normal emacs-lisp-mode-map (kbd "g d") 'elisp-slime-nav-find-elisp-thing-at-point)

      ;; I prefer C-a to jump to the beginning of the line.
      (define-key evil-insert-state-map "\C-a" nil)
      (define-key evil-insert-state-map "\C-y" nil)
      (define-key evil-insert-state-map "\C-e" nil)
      (define-key evil-insert-state-map "\C-k" nil)
      (define-key evil-insert-state-map "\C-u" nil)

      (define-key evil-normal-state-map (kbd "SPC /") 'helm-ag)
      (define-key evil-normal-state-map (kbd "SPC e") 'helm-projectile-recentf)
      (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)

      (evil-define-key 'normal js2-mode-map (kbd "g r") 'js2r-rename-var)
      (define-key evil-normal-state-map (kbd "g r") 'mc/mark-all-like-this-dwim)

      (define-key evil-operator-state-map (kbd "z") 'evil-ace-jump-char-mode)
      (define-key evil-normal-state-map (kbd "s") 'evil-ace-jump-char-mode)
      (define-key evil-motion-state-map (kbd "S-SPC") 'evil-ace-jump-line-mode)

      ;; escape minibuffer
      (define-key minibuffer-local-map [escape] 'my-minibuffer-keyboard-quit)
      (define-key minibuffer-local-ns-map [escape] 'my-minibuffer-keyboard-quit)
      (define-key minibuffer-local-completion-map [escape] 'my-minibuffer-keyboard-quit)
      (define-key minibuffer-local-must-match-map [escape] 'my-minibuffer-keyboard-quit)
      (define-key minibuffer-local-isearch-map [escape] 'my-minibuffer-keyboard-quit)

      (define-key minibuffer-local-map (kbd "C-w") 'backward-kill-word)

      (define-key magit-status-mode-map (kbd "C-n") 'magit-goto-next-sibling-section)
      (define-key magit-status-mode-map (kbd "C-p") 'magit-goto-previous-sibling-section)
      (define-key magit-status-mode-map (kbd "q") 'my-magit-quit-session)

      (define-key comint-mode-map [up] 'comint-previous-input)
      (define-key comint-mode-map [down] 'comint-next-input)

      ;; (define-key company-active-map (kbd "C-n") 'company-select-next)
      ;; (define-key company-active-map (kbd "C-p") 'company-select-previous)
      ;; (define-key company-active-map (kbd "<tab>") 'my-company-tab)
      ;; (define-key company-active-map (kbd "<backtab>") 'company-select-previous)

      ;; (define-key company-mode-map (kbd "<C-return>") 'helm-company)
      ;; (define-key company-active-map (kbd "<C-return>") 'helm-company)
      ;; (define-key web-mode-map (kbd "C-c C-d") 'ng-snip-show-docs-at-point)

      ))
#+END_SRC
** evil leader
#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :ensure t
    :init
    (progn
      (global-evil-leader-mode t)
      (setq evil-leader/in-all-states t)
      (evil-leader/set-leader ",")
      (evil-leader/set-key
        "w" 'save-buffer
        "e" 'eval-last-sexp
        "H" 'helm-org-headlines
        "E" 'eval-defun
        "f" 'ctl-x-5-prefix
        "j" 'org-open-at-point
        "C" 'customize-group
        "b d" 'kill-this-buffer
        "b z" 'bzshell
        "v" (kbd "C-w v C-w l")
        "s" (kbd "C-w s C-w j")
        "P" 'package-list-packages
        "h" help-map
        "h h" 'help-for-help-internal
        "g s" 'magit-status
        "g b" 'magit-blame-mode
        "g a" 'git-gutter+-stage-hunks
        "g r" 'git-gutter+-revert-hunks
        "g c" 'magit-commit
        "T"   'my-solarized-toggle
        "g l" 'magit-log)))
#+END_SRC
** comment operator (gc)
use evil-commentary
#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary :ensure t
    :config (evil-commentary-mode t))
#+END_SRC

** additional text objects
Add surround-style text objects.
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :ensure t
    :init (global-evil-surround-mode t))
#+END_SRC

indent text object
#+BEGIN_SRC emacs-lisp
  (use-package evil-indent-textobject
    :ensure t)
#+END_SRC

** evil org
#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :ensure t)
#+END_SRC

Also, let's make org-return work while we're at it.

#+BEGIN_SRC emacs-lisp
  (defun my-evil-ret (orig &rest args)
    (if (derived-mode-p 'org-mode)
        (org-return)
      (apply orig args)))

  (advice-add 'evil-ret :around #'my-evil-ret)
#+END_SRC

** evil-magit

#+BEGIN_SRC emacs-lisp
  (use-package evil-magit :ensure t)
#+END_SRC

** disable vi/vim style-exits
#+BEGIN_SRC emacs-lisp
  (defadvice evil-quit (around advice-for-evil-quit activate)
    (message "Thou shall not quit!"))

  (defadvice evil-quit-all (around advice-for-evil-quit-all activate)
    (message "Thou shall not quit!"))
#+END_SRC

* Stuff to look at
** TODO install rings
** TODO install scpaste
** TODO install spaces
** TODO install sublimity
** SODO install stripe-buffer
